import asyncio
from typing import AsyncIterator
import uuid
import sys

from grpclib.utils import graceful_exit
from grpclib.server import Server
from loguru import logger

# generated by protoc
from generated.message import MessageBase
from generated.message import MessageResponse


class MessageImpl(MessageBase):
    async def stream_message(
        self, request_id: str, count: int
    ) -> AsyncIterator[MessageResponse]:
        logger.debug(f"request={request_id},{count}")
        index = 0
        while True:
            if count >= 0 and index >= count:
                # response = MessageResponse(request_id, str(uuid.uuid1()), 0, -1, "")
                # logger.debug(
                #     f"response={response.request_id},{response.response_id},{response.error_code},{response.index}"
                # )
                # return response
                return

            response = MessageResponse(request_id, str(uuid.uuid1()), 0, index, "")
            logger.debug(
                f"response={response.request_id},{response.response_id},{response.index},{response.error_code}"
            )
            yield response

            index += 1


async def main(host="127.0.0.1", port=50051):
    server = Server([MessageImpl()])
    # Note: graceful_exit isn't supported in Windows
    with graceful_exit([server]):
        await server.start(host, port)
        logger.debug(f"Serving on {host}:{port}")
        await server.wait_closed()


if __name__ == "__main__":
    asyncio.run(main(*sys.argv[1:]))
